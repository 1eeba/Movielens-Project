---
title: "Project 1 : Movielens Recommender System--Professional Certificate in Data Science"
author: "Leeba Ann Varghese"
date: "2022-09-28"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Introduction
Recommendation systems are one of the major applications of Machine learning in Data science. They are widely used in large companies such as Netflix, YouTube, Amazon, Reddit etc. to predict user preferences, and return it to the users. This project is a part of the course -'Professional Certificate in Data science' launched by Harvard University and Edx. In this project, we use the Movielens dataset -the 10M Movielens dataset which was generated by the Grouplens research lab to develop the best possible algorithm that predicts user ratings for movies, using the entities available in the Movielens dataset and the knowledge acquired from the entire course. The whole dataset will be split into two- the Training set and Validation set .Different models will be tested on the training set .Finally, the approach with the best accuracy will be applied on the validation set .
# Project Objective

The objective of this project is to build a movie recommendation system using the Movielens dataset.The accuracy is measured by the metrics RMSE-Root Mean Squared Error. RMSE measures how far the predicted values deviate from the true values. Our aim is to develop a model with the least possible RMSE.

## R Markdown
# Installing required packages

if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")

# Loading required packages
library(tidyverse)
library(caret)
library(data.table)
library(dplyr)

# Loading the source files
dl <- tempfile()
download.file("https://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

head(ratings)

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")
head(movies)

movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(movieId),
                                           title = as.character(title),
                                           genres = as.character(genres))

head(movies)

# Data Cleanup - Preparation of Data

movielens <- left_join(ratings, movies, by = "movieId")
head(movielens)
str(movielens)

# Data Modeling - Splitting the data 
set.seed(1, sample.kind="Rounding") # if using R 3.5 or earlier, use `set.seed(1)`
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]

count(movielens)
count(edx)
count(temp)


# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>% 
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

head(validation)

# Add rows removed from validation set back into edx set

removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)

dim(edx)


# Create train and test sets
set.seed(1, sample.kind="Rounding")
test_index <- createDataPartition(y = edx$rating, times = 1, p = 0.1, list = FALSE)
train_set <- edx[-test_index,]
temp <- edx[test_index,]

# Matching userId and movieId in both train and test sets
test_set <- temp %>%
  semi_join(train_set, by = "movieId") %>%
  semi_join(train_set, by = "userId")

# Adding back rows into train set
removed <- anti_join(temp, test_set)
train_set <- rbind(train_set, removed)

rm(test_index, temp, removed)

dim(edx)
dim(test_set)
dim(train_set)


# 	Data Analysis and Data Visualization

# Structure and first 6 rows of edx dataset
str(edx)
head(edx)

#Distinct number of Movies,Users and Genres 

edx %>% summarize(n_users = n_distinct(userId), n_movies = n_distinct(movieId),n_genres=n_distinct(genres))

#Number of movies in each genre


genres = c("Drama", "Comedy", "Thriller", "Romance")
sapply(genres, function(g) {
  sum(str_detect(edx$genres, g))
})





#Top 10 most rated movies in the dataset
edx %>%
  group_by(title) %>%
  summarize(count = n()) %>%
  top_n(10, count) %>%
  arrange(-count) %>%
  ggplot(aes(count, reorder(title, count))) +
  geom_bar(color = "black", fill = "blue", stat = "identity") +
  xlab("Ratings Count") +
  ylab("Movie Name") +
  theme_bw()

# Plot of the most common ratings
We see that the  most commonly used rating is 4 . 

edx %>% group_by(rating) %>%
  summarise(n_ratings=n()) %>%
  top_n(5, n_ratings) %>%
  arrange(desc(n_ratings))%>%
plot

  
#Number of Rating versus movies:

edx %>% group_by(movieId) %>%
  summarize(count = n()) %>%
  ggplot(aes(count)) +
  geom_histogram(color = "black", fill = "deepskyblue2", bins = 40) +
  xlab("Ratings") +
  ylab("Movies") +
  scale_x_log10() +
  theme_bw()

#Number of Rating versus users

edx %>% group_by(userId) %>%
  summarize(count = n()) %>%
  ggplot(aes(count)) +
  geom_histogram(color = "black", fill = "deepskyblue2", bins = 40) +
  xlab("Ratings") +
  ylab("Users") +
  scale_x_log10() +
  theme_bw()

 # Top 10 most rated genres
 
edx%>%
  group_by(genres) %>%
  summarize(avg_rating = mean(rating), num_reviews = n()) %>%
  arrange(desc(avg_rating)) %>% head(10)

#Least 10 rated genres
edx%>%
  group_by(genres) %>%
  summarize(avg_rating= mean(rating), num_reviews = n()) %>%
  arrange(avg_rating) %>% head(10)

#Genres verus ratings

edx%>%
  group_by(genres) %>%
  summarize(count = n()) %>%
  ggplot(aes(count)) + 
  scale_x_log10() +
  geom_histogram(color = "black", fill = "deepskyblue2", bins = 40) + labs(x = 'Number of Ratings', y = 'Number of Genres')

# Evaluation Metric 
The evaluation metric used in this project will be the RMSE- Root mean square error. Several models will be used and the assessment will be based on the least value of RMSE achieved.It measures the error of a model in predicting quantitative data by measuring the difference between actual and predicted values. 

RMSE <- function(true_ratings, predicted_ratings){
  sqrt(mean((true_ratings - predicted_ratings)^2))
}

# Data Modeling  Approaches- Building the Models

#Model 1 : Using the mean - RMSE : 1.060054
  
mu <- mean(train_set$rating)
mu

result_model1 <- RMSE(test_set$rating,mu)
result_model1

The RMSE obtained using this model is 1.060054.The value is greater than 1 and it lacks accuracy.

#Model 2 :Using the median 

med <- median(train_set$rating)
med
result_model2 <- RMSE(test_set$rating,med)
result_model2

The RMSE obtained using this model is 1.166756,which is slightly higher than while using the mean. Hence, we will use mean of ratings in our further models.

#Model 3 :Mean and Movie bias(mb)

In this model, along with the mean we have also considered the average rating of each individual movie, as we have seen that more popular movies have received higher ratings. 

mb <- train_set %>%
  group_by(movieId) %>%
  summarize(mb_i = mean(rating - mu))


predicted_ratings <- mu + test_set %>%
  left_join(mb, by = "movieId") %>%
  pull(mb_i)

result_model3 <- RMSE(predicted_ratings, test_set$rating)

result_model3

#Model 4 : Mean(mu),Movie bias(mb),User bias(ub)

 In this model, along with the mean and average movie rating, we have also considered the average user rating 
 
ub <- train_set %>%
  left_join(mb, by = "movieId") %>%
  group_by(userId) %>%
  summarize(ub_i = mean(rating - mu - mb_i))


predicted_ratings <- test_set %>%
  left_join(mb, by = "movieId") %>%
  left_join(ub, by = "userId") %>%
  mutate(pred = mu + mb_i + ub_i) %>%
  pull(pred)      

result_model4 <- RMSE(predicted_ratings, test_set$rating)

result_model4

#Model 5 Mean(mu),Movie bias(mb),User bias(ub),Genre bias(gb)

In this model, along with the mean, average of movie rating and user rating, I have also considered the effect of movie genre.

gb <- train_set %>%
  left_join(mb, by = "movieId") %>%
  left_join(ub, by = "userId") %>%
  group_by(genres) %>%
  summarize(gb_i = mean(rating - mu - mb_i - ub_i))


predicted_ratings <- test_set %>%
  left_join(mb, by = "movieId") %>%
  left_join(ub, by = "userId") %>%
  left_join(gb, by = "genres") %>%
  mutate(pred = mu + mb_i + ub_i + gb_i) %>%
  pull(pred)      

result_model5 <- RMSE(predicted_ratings, test_set$rating)

result_model5


#Model 6 :  Regularization by calculating the least lambda

lambdas <- seq(0, 5, 0.25)

#find out the least lambda

rmses <- sapply(lambdas,function(l){
  
  #Calculate the mean of ratings from the edx training set
  mu <- mean(edx$rating)
  
  #Adjust mean by movie bias and penalize low number on ratings
  mb_i <- edx %>% 
    group_by(movieId) %>%
    summarize(mb_i = sum(rating - mu)/(n()+l))
  
  #Adjust mean by user and movie bias and penalize low number of ratings
  mb_u <- edx %>% 
    left_join(mb_i, by="movieId") %>%
    group_by(userId) %>%
    summarize(mb_u = sum(rating - mb_i - mu)/(n()+l))
  
  #predict ratings in the training set to derive lease  value of lambda
  
  predicted_ratings <- 
    edx %>% 
    left_join(mb_i, by = "movieId") %>%
    left_join(mb_u, by = "userId") %>%
    mutate(pred = mu + mb_i + mb_u) %>%
    .$pred
  
  return(RMSE(predicted_ratings, edx$rating))
})

# Plot the lambda and RMSEs
plot(lambdas, rmses)
    
min_lambda <- lambdas[which.min(rmses)]
min_lambda

min_rmse <- min(rmses)
min_rmse

result_model6 <- min_rmse

#Model 7 :Approach using Matrix Factorization

In this approach, we  process our data as a large and sparse matrix and then decompose into two smaller dimensional matrices with less sparsity.We will utilize  the recosystem package in this model.

#Convert data into recosystem format
install.packages('recosystem')
library(recosystem)
set.seed(1, sample.kind="Rounding")
train_reco <- with(train_set, data_memory(user_index = userId, item_index = movieId, rating = rating))
test_reco <- with(test_set, data_memory(user_index = userId, item_index = movieId, rating = rating))
r <- Reco()

para_reco <- r$tune(train_reco, opts = list(dim = c(20, 30),
                                            costp_l2 = c(0.01, 0.1),
                                            costq_l2 = c(0.01, 0.1),
                                            lrate = c(0.01, 0.1),
                                            nthread = 4,
                                            niter = 10))

r$train(train_reco, opts = c(para_reco$min, nthread = 4, niter = 30))
results_reco <- r$predict(test_reco, out_memory())

#Calculate RMSE
result_model7  <- RMSE(results_reco, test_set$rating)




#Application to Validation set

We will apply the Model 7 - Approach using Matrix Factorization with recosystem to the validation set and see the accuracy .

set.seed(1, sample.kind="Rounding")
edx_reco <- with(edx, data_memory(user_index = userId, item_index = movieId, rating = rating))
validation_reco <- with(validation, data_memory(user_index = userId, item_index = movieId, rating = rating))
r <- Reco()

para_reco <- r$tune(edx_reco, opts = list(dim = c(20, 30),
                                          costp_l2 = c(0.01, 0.1),
                                          costq_l2 = c(0.01, 0.1),
                                          lrate = c(0.01, 0.1),
                                          nthread = 4,
                                          niter = 10))

r$train(edx_reco, opts = c(para_reco$min, nthread = 4, niter = 30))

final_reco <- r$predict(validation_reco, out_memory())
final_rmse <- RMSE(final_reco, validation$rating)
final_rmse

# Conclusion

We have tried several models taught in this course series to provide a best movie rating prediction with the best accuracy and least RMSE. Below is the summary of all the models we have tried and the RMSEs. We see that the best approach is Matrix Factorization using recosystem, even though it is time consuming and utlilization of RAM is more compared to other models.
